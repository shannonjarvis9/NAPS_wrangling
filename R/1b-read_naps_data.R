library(stringi)
library(data.table)
library(openxlsx)
library(httr)
library(readxl)
library(janitor)
library(dplyr)
library(gdata)
library(lubridate)

# In this script, the files within each directory (created in 1a) are read into
# a list

source('~/NAPS_project/NAPS_wrangling/R/0-setup_project.R') # setup the working dir




#--------------------------------------------------------------------------------  
# Let's define some functions to use later

# Needed different 
#--------------------------------------------------------------------------------

## Function: getHeader
# Finds row index of the header
## -----------------------------------------------------
## Inputs: file:  file to be read
## Output: i, the row which contains the header
##         or 0 if something went wrong 
## Process: Looks for a row that contains "NAPS" or "Date", returns the index of
##          that row
getHeader <- function(file){
  found_header <- i <- 0L  # found header is FALSE
  while(found_header == FALSE & i < nrow(file)){
    i <- i+1
    if(any(grep(paste0( c("NAPS", "Date") , sep = "", collapse = "|"), file[i,], 
                ignore.case = TRUE, value = FALSE))){
      found_header <- TRUE
    }
  }
  
  if(found_header == FALSE){
    warning("Header cannot be found in the file")
    return(0)
  } else {
    return(i)
  }
}



## Function: removeEmptyRows
## -----------------------------------------------------
## Process: Removes rows that are all NA (except the date)
 removeEmptyRowsCols <- function(dt_frm){
  #df[rowSums(is.na(df)) < ncol(df)-1, colSums(is.na(df))<nrow(df)]
  dt_frm[!all(is.na(dt_frm[,2:ncol(dt_frm)])), ] #colSums(is.na(dt_frm))<nrow(dt_frm)]
     
  #df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)]
  
}

 
 
## Function: getNumericalCols
## -----------------------------------------------------
## Output: list of cols to convert to numeric 
## Process: Gets columns names that should be numeric (i.e. all cols that aren't
##          in the charCol vector - I identified to be characters)
getNumericalCols <- function(dt_frm){
  # vector of columns names that should be characters 
  # (generated by looking at all possible col names)
  charCol <- c("sample_type", "sampling_type", "c_f", "cart", "cartridge", "media", 
               "f_c", "fraction", "NAPS", "Date", "flag", "time", "x0", "id", "na") 
  
  grep(paste0(charCol , sep = "", collapse = "|"), names(dt_frm), 
       ignore.case = TRUE, value = TRUE, invert = TRUE)
}



## Function: delete_na_rows
## -----------------------------------------------------
# Removes rows that has more the n blank values 
delete_na_rows <- function(df, n) {
  df[rowSums(is.na(df)) <= n, ]
}



## Function: getFile_xlsx
## -----------------------------------------------------
## Inputs: file_path: path of excel file to be read
##         sheet: sheet of file to be read 
## Output: a data frame with the appropriately formatted data frame column names 
## For 2011+ NAPS data
getFile_xlsx <- function(file_path, sheet){

  tmp <- suppressMessages(read_excel(file_path, sheet = sheet, col_names = FALSE,
                                     na = c("NA","", " ", "-", "-999","-999.000"), trim_ws = TRUE))
  i <- getHeader(tmp)
  
  if(i == 0){
    return(stop(paste0("Header cannot be found in ", file_path, ", stopping exectution.")))
  }
  
  df <- removeEmptyRowsCols(tmp[i+1:nrow(tmp),])
  names(df) <-  tmp[i,] 
  df_col <- getNumericalCols(df %>%  clean_names())
  
  df <- df  %>% 
    clean_names()  %>%
    mutate(date = as.Date(as.numeric(sampling_date), origin =  "1899-12-30"), 
           year = year(date), month = month(date), day = day(date)) %>%
    mutate_at(getNumericalCols(df %>%  clean_names()) ,as.numeric)  %>%
    select(-c(contains("TIME"), "sampling_date", contains("naps"))) %>%
    relocate(all_of(c("date", "year", "month", "day")), after = 1) 
  
  df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)] # remove na

}



## Function: getFile_xls
## -----------------------------------------------------
## Inputs: file_path: path of file to be read
## Output: a data frame with the appropriately formatted data frame column names  
##          for 2003-2010 NAPS xls data
##          read_excel() has issues reading .xls 
getFile_xls <- function(file_path){
  tmp <- read.xls(file_path, na.strings = c("NA","", " ", "-", "-999","-999.000"))
  i <- getHeader(tmp)
  
  if(i == 0){
    return(stop(paste0("Header cannot be found in ", file_path, ", stopping exectution.")))
  }
  
  df <- (tmp[i+1:nrow(tmp),])
  names(df) <-  tmp[i,]
  df <- removeEmptyRowsCols(df)
  
  df_col <- getNumericalCols( df %>%  clean_names())
  
  df <- df %>% 
    clean_names() %>%
    mutate(date = as.Date(date)) %>%
    mutate(year = year(date), month = month(date), day = day(date)) %>%
    mutate_at(df_col,as.numeric)  %>%
    select(-c(contains("TIME"), contains("naps"))) %>%
    relocate(all_of(c("date", "year", "month", "day")), after = 1)
  
  df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)] 
}



## Function: readData_xlsx_sheets
## -----------------------------------------------------
## Input: dir - a directory of xlsx files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> Sheet name -> Data 
readData_xlsx_sheets <- function(dir){
  FilesSheets <- getFilesandSheets(dir)
  
  # generate the header data frame
  station <- unlist(lapply(strsplit(FilesSheets$files, "_"), "[[", 4)) 
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(s in unique(station)){
    lst[[s]] <- vector("list", length = length(FilesSheets$sheetnames))
    names(lst[[s]]) <- FilesSheets$sheetnames
  }
  
  for(i in 1:length(FilesSheets$files)){
    stn <- station[i]
    for(t in FilesSheets$sheetnames[FilesSheets$sheetnames %in% excel_sheets(FilesSheets$files[i])]){
      tmp <- getFile_xlsx(FilesSheets$files[i], t)
      if(length(lst[[stn]][[t]]) == 0){
        lst[[stn]][[t]] <- tmp
      }else {
        lst[[stn]][[t]] <- merge(lst[[stn]][[t]], tmp, all.x = TRUE, all.y = TRUE,
                                    by = intersect(names(lst[[stn]][[t]]), names(tmp)))
      }
      print(sprintf("Read %s, sheet %s",FilesSheets$files[i], t))
    }
  }
  
  lst
}



## Function: readData_xls_nosheets
## -----------------------------------------------------
## Input: dir - a directory of xls files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> Data 
## -----------------------------------------------------
readData_xls_nosheets <- function(dir){
  files <- list.files(path = paste0(wd$data, dir), full.names = TRUE)
  station <- unlist(lapply(strsplit(files, "_|\\."), "[[", 4)) 
  
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(i in 1:length(files)){
    tmp <- getFile_xls(files[i])
    if(length(lst[[station[i]]]) == 0){
      lst[[station[i]]] <- tmp
    }else {
      lst[[station[i]]] <- merge(lst[[station[i]]], tmp, all.x = TRUE, all.y = TRUE,
                                    by = intersect(names(lst[[station[i]]]), names(tmp)))
      
    }
    print(sprintf("Read %s, %.1f %% read",files[i], round((i/length(files))*100,2)))
  }
  
  lst
}



## Function: readData_xls_sheets
## -----------------------------------------------------
## Input: dir - a directory of xls files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> File type -> Data 
## -----------------------------------------------------
readData_xls_sheets <- function(dir){
  
  files <- list.files(path = paste0(wd$data, dir), full.names = TRUE)
  file_type <- unlist(lapply(strsplit(files, "_|\\."), "[[", 5)) 
  station <- unlist(lapply(strsplit(files, "_|\\."), "[[", 4)) 
  
  #generate the list to hold all spec files 
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(s in unique(station)){
    lst[[s]] <- vector("list", length = length(unique(file_type)))
    names(lst[[s]]) <- unique(file_type)
  }
  
  for(i in 1:length(files)){
    tmp <- getFile_xls(files[i])
    if(length(lst[[station[i]]][[file_type[i]]]) == 0){
      lst[[station[i]]][[file_type[i]]] <- tmp
    }else {
      lst[[station[i]]][[file_type[i]]] <- merge(lst[[station[i]]][[file_type[i]]], tmp, all.x = TRUE, all.y = TRUE,
                                                    by = intersect(names(lst[[station[i]]][[file_type[i]]]), names(tmp)))
    }
    print(sprintf("Read %s, %s, %s",files[i], station[i], file_type[i]))
  }
  
  lst
}


## Function: getFilesandSheets
## -----------------------------------------------------
## Input: d - the directory of interest
## Output: a list of the excel files within the directory and its sheets
getFilesandSheets <- function(d){
  files <- list.files(path = paste0(wd$data, d), full.names = TRUE)
  
  # Don't want to read metadata, changelogs or station info 
  sheetnames <- grep('metadata|change|csv|station', unique(unlist(lapply(files, function(i){excel_sheets(i)}))) , 
                     ignore.case = TRUE, invert = TRUE, value = TRUE)
  
  list("files" = files, "sheetnames" = sheetnames)
}





#--------------------------------------------------------------------------------  
# Let's use the functions to read files from each directory 
#--------------------------------------------------------------------------------

## Read the files
## -----------------------------------------------------
pm10dat <- readData_xlsx_sheets("IntegratedPM2.5-10")
pm25dat <- readData_xlsx_sheets("IntegratedPM2.5")
spec <- readData_xls_sheets("PMSPECIATION") 
pmpart <- readData_xls_nosheets("PMPART25")
dichot <- readData_xls_nosheets("PMDICHOT")


# remove empty stations/elements of the list
spec <- lapply(spec, function(x){Filter(Negate(is.null), x)})
pmpart <- lapply(pmpart, function(x){Filter(Negate(is.null), x)})
pm10dat <- lapply(pm10dat, function(x){Filter(Negate(is.null), x)})
pm25dat <- lapply(pm25dat, function(x){Filter(Negate(is.null), x)})
dichot <- lapply(dichot, function(x){Filter(Negate(is.null), x)})


save(file = paste0(wd$output, "spec_read.rda"), spec)
save(file = paste0(wd$output, "pmpart_read.rda"), pmpart)
save(file = paste0(wd$output, "pm10_read.rda"), pm10dat)
save(file = paste0(wd$output, "pm25_read.rda"), pm25dat)
save(file = paste0(wd$output, "dichot_read.rda"), dichot)
