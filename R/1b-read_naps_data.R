library(stringi)
library(data.table)
library(openxlsx)
library(httr)
library(readxl)
library(janitor)
library(dplyr)
library(gdata)
library(lubridate)
library(rlang) # for is_empty

# In this script, the files within each directory (created in 1a) are read into
# a list

source('~/NAPS_project/NAPS_wrangling/R/0-setup_project.R') # setup the working dir



#--------------------------------------------------------------------------------  
# Let's define some functions to use later
#--------------------------------------------------------------------------------

## Function: getHeader
# Finds row index of the header
## -----------------------------------------------------
## Inputs: file:  file to be read
## Output: i, the row which contains the header
##         or 0 if something went wrong 
## Process: Looks for a row that contains "NAPS" or "Date", returns the index of
##          that row
getHeader <- function(file){
  found_header <- i <- 0L  # found header is FALSE
  while(found_header == FALSE & i < nrow(file)){
    i <- i+1
    if(any(grep(paste0( c("NAPS", "Date") , sep = "", collapse = "|"), file[i,], 
                ignore.case = TRUE, value = FALSE))){
      found_header <- TRUE
    }
  }
  
  if(found_header == FALSE){
    warning("Header cannot be found in the file")
    return(0)
  } else {
    return(i)
  }
}



## Function: removeEmptyRows
## -----------------------------------------------------
## Process: Removes rows that are all NA (except the date)
removeEmptyRowsCols <- function(dt_frm){
  #df[rowSums(is.na(df)) < ncol(df)-1, colSums(is.na(df))<nrow(df)]
  dt_frm[!all(is.na(dt_frm[,2:ncol(dt_frm)])), ] #colSums(is.na(dt_frm))<nrow(dt_frm)]
  
  #df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)]
  
}



## Function: getNumericalCols
## -----------------------------------------------------
## Output: list of cols to convert to numeric 
## Process: Gets columns names that should be numeric (i.e. all cols that aren't
##          in the charCol vector - I identified to be characters)
getNumericalCols <- function(dt_frm){
  # vector of columns names that should be characters 
  # (generated by looking at all possible col names)
  charCol <- c("sample_type", "sampling_type", "c_f", "cart", "cartridge", "media", 
               "f_c", "fraction", "NAPS", "Date", "flag", "time", "x0", "id", "na") 
  
  grep(paste0(charCol , sep = "", collapse = "|"), names(dt_frm), 
       ignore.case = TRUE, value = TRUE, invert = TRUE)
}



## Function: delete_na_rows
## -----------------------------------------------------
# Removes rows that has more the n blank values 
delete_na_rows <- function(df, n) {
  df[rowSums(is.na(df)) <= n, ]
}



## Function: getFile_xlsx
## -----------------------------------------------------
## Inputs: file_path: path of excel file to be read
##         sheet: sheet of file to be read 
##         SamplerInfo: description and code of sampler
## Output: a data frame with the appropriately formatted data frame column names 
## For 2011+ NAPS data
getFile_xlsx <- function(file_path, sheet, samplerInfo){
  
  tmp <- suppressMessages(read_excel(file_path, sheet = sheet, col_names = FALSE,
                                     na = c("NA","", " ", "-", "-999","-999.000"), trim_ws = TRUE))
  
  i <- getHeader(tmp)
  
  if(i == 0){stop(paste0("Header cannot be found in ", file_path, ", stopping exectution."))}
  
  df <- removeEmptyRowsCols(tmp[i+1:nrow(tmp),])
  names(df) <-as.character(as.vector(tmp[i,]))
  df_col <- getNumericalCols(df %>%  clean_names())
  
  # need the filter info 
  if(sheet == "Ions-Spec_IC"){
    row <- which(tmp[,1] == "Medium")
    if(is_empty(row)){
      warning(paste0("Medium info cannot be found in ", file_path, ", ", sheet))
    } else {
      med <- sub("N/A|Medium", NA, as.character(as.vector(tmp[row,])) , ignore.case = TRUE)
      idx_med <- which(!is.na(med))
      names(df)[idx_med] <- paste0(med[idx_med], "_", names(df)[idx_med])
    }
  }
  # need the sampler info 
  row <- which(tmp[,1] == "Sampler")
    if(is_empty(row)){
      warning(paste0("Sampler info cannot be found in ", file_path, ", ", sheet))
    } else if(nrow(samplerInfo) != 0){
      sampler <- sub("N/A|Sampler", NA, as.character(as.vector(tmp[row,])) , ignore.case = TRUE)
      idx_sampler <- which(!is.na(sampler))
      
      #get the values from the Station dictionary
      S1_val <-as.character(samplerInfo %>% filter(SamplerNum == "S-1") %>% select(type)) 
      S2_val <- as.character(samplerInfo %>% filter(SamplerNum == "S-2") %>% select(type))
      
      #add spec/dich to the names if needed 
      sampler <- sub("S-1", if(S1_val == "character(0)"){""}else{S1_val}, sampler)
      sampler <- sub("S-2", if(S2_val == "character(0)"){""}else{S2_val}, sampler) 
      
      names(df)[idx_sampler] <- paste0(sampler[idx_sampler], "_", names(df)[idx_sampler])
    }
   
  
  df <- df  %>% 
    clean_names()  %>%
    mutate(date = as.Date(as.numeric(sampling_date), origin =  "1899-12-30"), 
           year = year(date), month = month(date), day = day(date)) %>%
    mutate_at(getNumericalCols(df %>%  clean_names()) ,as.numeric)  %>%
    select(-c(contains("TIME"), "sampling_date", contains("naps"))) %>%
    relocate(all_of(c("date", "year", "month", "day")), after = 1) 
  
  df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)] # remove na
  
}



## Function: getFile_xls
## -----------------------------------------------------
## Inputs: file_path: path of file to be read
## Output: a data frame with the appropriately formatted data frame column names  
##          for 2003-2010 NAPS xls data
##          read_excel() has issues reading .xls 
getFile_xls <- function(file_path){
  tmp <- read.xls(file_path, na.strings = c("NA","", " ", "-", "-999","-999.000"))
  i <- getHeader(tmp)
  
  if(i == 0){
    return(stop(paste0("Header cannot be found in ", file_path, ", stopping exectution.")))
  }
  
  df <- (tmp[i+1:nrow(tmp),])
  names(df) <-  tmp[i,]
  df <- removeEmptyRowsCols(df)
  
  df_col <- getNumericalCols( df %>%  clean_names())
  
  df <- df %>% 
    clean_names() %>%
    mutate(date = as.Date(date)) %>%
    mutate(year = year(date), month = month(date), day = day(date)) %>%
    mutate_at(df_col,as.numeric)  %>%
    select(-c(contains("TIME"), contains("naps"))) %>%
    relocate(all_of(c("date", "year", "month", "day")), after = 1)
  
  df[rowSums(is.na(df))<ncol(df),colSums(is.na(df))<nrow(df)] 
}



## Function: readData_xlsx_sheets
## -----------------------------------------------------
## Input: dir - a directory of xlsx files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> Sheet name -> Data 
readData_xlsx_sheets <- function(dir){
  FilesSheets <- getFilesandSheets(dir)
  SamplerDict <- getSamplerInfo(dir)
  
  # generate the header data frame
  station <- unlist(lapply(strsplit(FilesSheets$files, "_"), "[[", 4)) 
  year <- unlist(lapply(strsplit(FilesSheets$files, "_|/"), "[[", 10)) 
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(s in unique(station)){
    lst[[s]] <- vector("list", length = length(FilesSheets$sheetnames))
    names(lst[[s]]) <- FilesSheets$sheetnames
  }
  
  for(i in 1:length(FilesSheets$files)){
    stn <- station[i]
    yr <- year[i]

    for(t in FilesSheets$sheetnames[FilesSheets$sheetnames %in% excel_sheets(FilesSheets$files[i])]){
      tmp <- getFile_xlsx(FilesSheets$files[i], t, 
                          SamplerDict %>% filter(Station == !!stn & Year == !!yr))
      
      if(length(lst[[stn]][[t]]) == 0){
        lst[[stn]][[t]] <- tmp
      }else {
        lst[[stn]][[t]] <- merge(lst[[stn]][[t]], tmp, all.x = TRUE, all.y = TRUE,
                                 by = intersect(names(lst[[stn]][[t]]), names(tmp)))
      }
      print(sprintf("Read %s, sheet %s",FilesSheets$files[i], t))
    }
  }
  
  lst
}



## Function: readData_xls_nosheets
## -----------------------------------------------------
## Input: dir - a directory of xls files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> Data 
## -----------------------------------------------------
readData_xls_nosheets <- function(dir){
  files <- list.files(path = paste0(wd$data, dir), full.names = TRUE)
  station <- unlist(lapply(strsplit(files, "_|\\."), "[[", 4)) 
  
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(i in 1:length(files)){
    tmp <- getFile_xls(files[i])
    if(length(lst[[station[i]]]) == 0){
      lst[[station[i]]] <- tmp
    }else {
      lst[[station[i]]] <- merge(lst[[station[i]]], tmp, all.x = TRUE, all.y = TRUE,
                                 by = intersect(names(lst[[station[i]]]), names(tmp)))
      
    }
    print(sprintf("Read %s, %.1f %% read",files[i], round((i/length(files))*100,2)))
  }
  
  lst
}



## Function: readData_xls_sheets
## -----------------------------------------------------
## Input: dir - a directory of xls files to read
## Output: a list of lists containing the dir contents 
##         List is arranged as Station -> File type -> Data 
## -----------------------------------------------------
readData_xls_sheets <- function(dir){
  
  files <- list.files(path = paste0(wd$data, dir), full.names = TRUE)
  file_type <- unlist(lapply(strsplit(files, "_|\\."), "[[", 5)) 
  station <- unlist(lapply(strsplit(files, "_|\\."), "[[", 4)) 
  
  #generate the list to hold all spec files 
  lst <- vector("list", length(unique(station)))
  names(lst) <- unique(station)
  
  for(s in unique(station)){
    lst[[s]] <- vector("list", length = length(unique(file_type)))
    names(lst[[s]]) <- unique(file_type)
  }
  
  for(i in 1:length(files)){
    tmp <- getFile_xls(files[i])
    if(length(lst[[station[i]]][[file_type[i]]]) == 0){
      lst[[station[i]]][[file_type[i]]] <- tmp
    }else {
      lst[[station[i]]][[file_type[i]]] <- merge(lst[[station[i]]][[file_type[i]]], tmp, all.x = TRUE, all.y = TRUE,
                                                 by = intersect(names(lst[[station[i]]][[file_type[i]]]), names(tmp)))
    }
    print(sprintf("Read %s, %s, %s",files[i], station[i], file_type[i]))
  }
  
  lst
}


## Function: getFilesandSheets
## -----------------------------------------------------
## Input: d - the directory of interest
## Output: a list of the excel files within the directory and its sheets
getFilesandSheets <- function(d){
  files <- list.files(path = paste0(wd$data, d), full.names = TRUE)
  
  # Don't want to read metadata, changelogs or station info 
  sheetnames <- grep('metadata|change|csv|station', unique(unlist(lapply(files, function(i){excel_sheets(i)}))) , 
                     ignore.case = TRUE, invert = TRUE, value = TRUE)
  
  list("files" = files, "sheetnames" = sheetnames)
}



## Function: getSamplerInfo
##--------------------------------------------------
## Input: dir: the directory of files 
## Output: a data frame containing the stations, years, sampler name and code
## Process: Reads the station info for each file to extract the sampler names and 
## corresponding code - requires time as it read all files in the provided dir
getSamplerInfo <- function(dir){
  files <- list.files(path = paste0(wd$data, dir), full.names = TRUE)
  file_names <- list.files(path = paste0(wd$data, dir), full.names = FALSE)
  station <- unlist(lapply(strsplit(file_names, "_"), "[[", 2))
  year <- unlist(lapply(strsplit(file_names, "_|\\."), "[[", 1)) 
  
  sampler_dict <- data.frame(Description = c(), Sampler = c(), 
                             SamplerNum = c(), Station = c(), Year = c())
  
  for(i in 1:length(files)){
    tmp <- suppressMessages(read_excel(files[i], sheet = "Station Info", col_names = FALSE,
                                       na = c("NA","", " ", "-", "-999","-999.000"), trim_ws = TRUE))
    
    c1 <- tmp %>% pull(`...1`)
    row <- grep("Sampler #", c1)
    
    samplers<- tmp[row+1,]
    samplers$sample <- str_match_all(c1[row], "(?<=\\().+?(?=\\))")
    samplers$station <- rep(station[i], length(row))
    samplers$year <- rep(year[i], length(row))
    names(samplers) <- c("Description","Sampler", "SamplerNum", "Station", "Year") 
    
    
    sampler_dict <- rbind(sampler_dict, samplers)
    rm(samplers)
  }
  
  all_samplers <- unique(sampler_dict) %>% 
    filter(Description == "Description") 
  
  all_spec_dich <- filter(all_samplers, grepl('dich|spec', all_samplers$Sampler, ignore.case = TRUE))
  
  mutate(all_spec_dich, type = ifelse(
    grepl('spec', all_spec_dich$Sampler, ignore.case = TRUE), "spec", "dich"))
  
}



#--------------------------------------------------------------------------------  
# Let's use the functions to read files from each directory 
#--------------------------------------------------------------------------------

## Read the files
## -----------------------------------------------------
pm10dat <- readData_xlsx_sheets("IntegratedPM2.5-10")
pm25dat <- readData_xlsx_sheets("IntegratedPM2.5")
spec <- readData_xls_sheets("PMSPECIATION") 
pmpart <- readData_xls_nosheets("PMPART25")
dichot <- readData_xls_nosheets("PMDICHOT")


# remove empty stations/elements of the list
spec <- lapply(spec, function(x){Filter(Negate(is.null), x)})
pmpart <- lapply(pmpart, function(x){Filter(Negate(is.null), x)})
pm10dat <- lapply(pm10dat, function(x){Filter(Negate(is.null), x)})
pm25dat <- lapply(pm25dat, function(x){Filter(Negate(is.null), x)})
dichot <- lapply(dichot, function(x){Filter(Negate(is.null), x)})


save(file = paste0(wd$output, "spec_read.rda"), spec)
save(file = paste0(wd$output, "pmpart_read.rda"), pmpart)
save(file = paste0(wd$output, "pm10_read.rda"), pm10dat)
save(file = paste0(wd$output, "pm25_read.rda"), pm25dat)
save(file = paste0(wd$output, "dichot_read.rda"), dichot)






